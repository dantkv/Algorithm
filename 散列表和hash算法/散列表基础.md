
## 散列函数基本要求    
1、散列函数计算得到的散列值是一个非负整数；    
2、如果 key1 = key2，那 hash(key1) == hash(key2)；    
3、如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。    

## 设计散列函数
1、不能太复杂    
2、尽可能使值均匀分布


散列表的**装载因子**=填入表中的元素个数/散列表的长度

装载因子越大，散列表里面值越多，出现冲突可能就越大。

如果是静态数据集合，没有频繁插入删除，可以根据数据特点设计出比较好的函数    
对于频繁变动的数据，随着数据量增加，冲突可能就会变大，那么可以申请新的空间，把数据移动到新位置。    
避免低效的扩容：如果新数据出现时达到阀值，重新申请新空间，将新数据装到新散列表，访问到旧散列表数据时，先移动到新的，直到全部移动完毕。这样使插入操作不至于在某个数据插入时效率急剧降低。   



## 解决冲突    
1、开放寻址法    
> 如果出现冲突，重新找一个空闲位置    
> 比如**线性探测法**：从当前位置开始，向后遍历，直到找到第一个空闲位置
> 当然这种方法随着可用空间变少，冲突概率会越来越大，最坏情况下，需要探测整个表，时间复杂度O(n)

适用场景：数据量比较小时候。

除了**线性探测法**，还有**二次探测**和**双重散列**    
二次探测：每次步长为i^2    
双重散列：使用一组散列函数，第一个函数冲突时，使用下一个函数，直到找到空闲位置

2、链表法    
> 每个散列值对应一个链表，遇到冲突直接插入链表中。    
> 查询时间与每个值的链表长度有关

适用场景：数据量大，大对象的数据。相比于开放寻址法，优化策略更多，更灵活

当链表法中链表长度过大，可以转换为更高效的数据结构，比如红黑树。

## 工业级散列表举例
Java中HashMap    
1、初始大小：16 。 如果事先直到容量，可以预先申请初始大小，减少扩容带来的性能损耗。    
2、装载因子和动态扩容  
默认0.75，超过后自动扩容两倍    
3、底层使用链表法解决冲突，在JDK1.8后，当链表长度超过8时会变成红黑树，小于8会退化成链表。

一个工业级散列表的要求    
1、支持快速插入、删除、查找操作
2、内存占用合理    
3、极端情况也性能不会退化到不能接受的程度

## 案例

案例1：Word文档的单词拼写检查功能实现    
假设每个单词10长度，常用单词20万个，总共占用内存2MB，可以使用散列表直接放在内存。    

案例2：:10万条日志，根据访问次数排序    
遍历日志，key为URL，value为访问次数，同时记录下最大次数    
如果k比较小，可以桶排序，比较大使用快速排序

使用散列表的意义：方便统计使用次数，直接比较URL非常耗费时间。



案例3：有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串   
先对第一个数组建立散列表，key为字符串，value为次数，然后遍历第二个数组，查询是否有冲突。

比较相邻两个元素的大小，根据大小关系交换位置    
从头开始进行遍历，每次遍历将最小或者最大的元素移动到末尾    
这样重复n次完成整个数组排序    

```Java
public void bubblesort(int arr[], int len)
{
    for(int i = 0; i < arr.length; i++)
    {
        for(int j = 0; j < arr.length - i-1; j++)
        {
            if(arr[i] < arr[j])
            {
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
    }
}
```

**改进版本**

当某次遍历没有交换动作，那么表示已经全部是有序状态，这时可以提前退出循环
```Java
public void bubblesort(int arr[], int len)
{
    for(int i = 0; i < arr.length; i++)
    {
        boolean flg = false;
        for(int j = 0; j < arr.length - i-1; j++)
        {
            if(arr[i] < arr[j])
            {
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
                flg = true;
            }
        }
        if(!flg) break;
    }
}
```


* 时间复杂度分析
    遍历次数为n+n-1+...+2+1 = (n^2 +n)/2    
    大O表示法描述时间复杂度为O(n^2)    

    **最好情况**，采用改进版本只需一次遍历。时间复杂度为O(n)    
    **最坏情况**，遍历n次。时间复杂度为O(n^2)    

    **平均时间复杂度**    
    对于n个元素的数组，有n!种排列方式，    
    用数组有序度和逆序度来分析。    

    `有序度：数组中有有序关系的元素对对的个数`    

    对于一个完全倒序的数组[6,5,4,3,2,1]，有序度为0    
    对于一个完全有序的数组[1,2,3,4,5,6]，有序度为(n-1) * n/2    

    逆序度 = 满有序度 - 有序度    
    ```
    次数          结果          有序度
    0           6,5,4,3,2,1     0
    1           5,4,3,2,1,6     5
    2           4,3,2,1,5,6     9
    3           3,2,1,4,5,6     12
    4           2,1,3,4,5,6     14
    5           1,2,3,4,5,6     15
    ```
    冒泡排序包含比较和交换两种原子操作。对于确定的数组，交换的次数是一定的，就是逆序度

    对于n个元素的数组，最好逆序度0，最坏逆序度n * (n-1)/2，取平均值n * (n-1)/4    
    即平均情况下需要进行n * (n-1)/4 次交换，用大O表示描述为O(n^2)    

* 是否原地排序    
    是原地排序，只使用常数级别辅助空间，空间复杂度为O(1)

* 是稳定排序算法吗    
    只是对前后元素交换位置，如果大小关系相同不交换位置，因此不改变前后顺序关系
